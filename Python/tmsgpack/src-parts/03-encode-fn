# We may want to optimize codec access in the future:
ctypedef object TMsgpackCodec

cdef class EncodeCtx:
    cdef TMsgpackCodec    codec
    cdef BaseEncodeBuffer ebuf
    cdef readonly object  value
    cdef bint             used

    def __cinit__(self, TMsgpackCodec codec, BaseEncodeBuffer ebuf):
        self.codec = codec
        self.ebuf  = ebuf
        self.value = None
        self.used  = True    # Set to False direclty before use.

    cdef _v(self, value):
        self.value = value
        self.used  = False
        return self

    cdef mark_use(self, bint expect_used):
        if expect_used is not self.used:
            if expect_used: raise TMsgpackEncodingError('ectx was not used.')
            else:           raise TMsgpackEncodingError('ectx used twice.')
        self.used = True

    cpdef put_bytes(self, object _type, object value):
        cdef BaseEncodeBuffer ebuf = self.ebuf
        cdef uint64_t         _len
        self.mark_use(False)
        if type(value) is not bytes: raise TMsgpackEncodingError(f'not bytes: {value}')

        bytes_val = <bytes>value
        _len = <uint64_t>len(bytes_val)

        if   _len ==  0:     ebuf.put_uint1(FixBytes0)
        elif _len ==  1:     ebuf.put_uint1(FixBytes1)
        elif _len ==  2:     ebuf.put_uint1(FixBytes2)
        elif _len ==  4:     ebuf.put_uint1(FixBytes4)
        elif _len ==  8:     ebuf.put_uint1(FixBytes8)
        elif _len == 16:     ebuf.put_uint1(FixBytes16)
        elif _len == 20:     ebuf.put_uint1(FixBytes20)
        elif _len == 32:     ebuf.put_uint1(FixBytes32)
        elif _len < ui1_max: ebuf.put_uint1(VarBytes1).put_uint1(<uint8_t>_len)
        elif _len < ui2_max: ebuf.put_uint1(VarBytes2).put_uint2(<uint16_t>_len)
        else:                ebuf.put_uint1(VarBytes8).put_uint8(<uint64_t>_len)

        ectx_put_value(self, _type)
        ebuf.put_bytes(bytes_val)

    cpdef put_sequence(self, object _type, object value):
        cdef uint64_t _len = <uint64_t>len(value)
        self.mark_use(False)

        _tuple_header(self.ebuf, _len)
        ectx_put_value(self, _type)

        for v in value: ectx_put_value(self, v)

    cpdef put_dict(self, object _type, object value, bint sort=False):
        cdef object   pairs = value.items()
        cdef uint64_t _len  = <uint64_t>(2 * len(pairs))
        if sort: pairs = sorted(pairs)

        self.mark_use(False)
        _tuple_header(self.ebuf, _len)
        ectx_put_value(self, _type)

        for k, v in pairs:
            ectx_put_value(self, k)
            ectx_put_value(self, v)

    @property
    def sort_keys(self): return self.codec.sort_keys

cdef bint _tuple_header(BaseEncodeBuffer ebuf, uint64_t _len):
    if   _len < 17:      ebuf.put_uint1(<uint8_t>(FixTuple0 + _len))
    elif _len < ui1_max: ebuf.put_uint1(VarTuple1).put_uint1(<uint8_t>_len)
    elif _len < ui2_max: ebuf.put_uint1(VarTuple2).put_uint2(<uint16_t>_len)
    else:                ebuf.put_uint1(VarTuple8).put_uint8(<uint64_t>_len)

cpdef BaseEncodeBuffer ebuf_put_value(
    TMsgpackCodec codec, BaseEncodeBuffer ebuf, object value
):
    """Encode value to a msg and put it into ebuf."""
    return ectx_put_value(EncodeCtx(codec, ebuf), value)

cdef ectx_put_value(EncodeCtx ectx, object value):
    cdef TMsgpackCodec    codec = ectx.codec
    cdef BaseEncodeBuffer ebuf  = ectx.ebuf
    cdef int64_t int_val
    cdef bytes str_bytes
    cdef uint64_t _len
    cdef bint bool_val
    cdef bytes bytes_val
    cdef object pairs

    cdef object t = type(value)

    if t is int:
        # Cast to C int64_t for efficient comparisons and arithmetic
        int_val = PyLong_AsLongLong(value)

        if min_ConstNegInt <= int_val < 0:
            return ebuf.put_uint1(<uint8_t>(int_val + ui1_max))
        if 0 <= int_val < FixInt2:
            return ebuf.put_uint1(<uint8_t>int_val)

        if -i2_max <= int_val < i2_max:
            return ebuf.put_uint1(FixInt2).put_int2(<int16_t>int_val)
        if -i4_max <= int_val < i4_max:
            return ebuf.put_uint1(FixInt4).put_int4(<int32_t>int_val)
        else:
            return ebuf.put_uint1(FixInt8).put_int8(<int64_t>int_val)

    if t is float:
        return ebuf.put_uint1(FixFloat8).put_float8(<float64_t>value)

    if t is str:
        str_bytes = (<str>value).encode('utf8')
        _len = <uint64_t>len(str_bytes)

        # Str length header -- followed by string characters.
        if   _len < 16:      ebuf.put_uint1(<uint8_t>(FixStr0 + _len))
        elif _len < ui1_max: ebuf.put_uint1(VarStr1).put_uint1(<uint8_t>_len)
        elif _len < ui2_max: ebuf.put_uint1(VarStr2).put_uint2(<uint16_t>_len)
        else:                ebuf.put_uint1(VarStr8).put_uint8(<uint64_t>_len)

        return ebuf.put_bytes(str_bytes)

    if t is bool:
        bool_val = <bint>value
        if bool_val is True:  return ebuf.put_uint1(ConstValTrue)
        if bool_val is False: return ebuf.put_uint1(ConstValFalse)
        raise TMsgpackEncodingError(f'Illegal boolean value: {value}')

    if t is NoneType: return ebuf.put_uint1(ConstValNone)

    if   t is bytes: ectx._v(None).put_bytes(True, value)
    elif t is tuple: ectx._v(None).put_sequence(True, value)
    elif t is list:  ectx._v(None).put_sequence(False, value)
    elif t is dict:  ectx._v(None).put_dict(None, value, codec.sort_keys)
    else:            codec.decompose_value(ectx._v(value)); ectx.mark_use(True)

