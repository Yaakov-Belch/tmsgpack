# We may want to optimize codec access in the future:
ctypedef object TMsgpackCodec

cdef class EncodeCtx:
    cdef TMsgpackCodec    codec
    cdef BaseEncodeBuffer ebuf
    cdef readonly object  value
    cdef object           cache_key
    cdef bint             _used
    cdef dict             _decompose_value_cache
    cdef readonly bint    sort_keys
    cdef bint             use_cache

    def __cinit__(self, TMsgpackCodec codec, BaseEncodeBuffer ebuf):
        self.codec     = codec
        self.ebuf      = ebuf
        self.value     = None
        self.cache_key = None
        self._used     = True    # Set to False directly before use.
        self.sort_keys = codec.sort_keys
        self.use_cache = codec.use_cache
        self._decompose_value_cache = get_cached_dict(codec, '_decompose_value_cache')

    cdef _vk(self, value, cache_key):
        self.value     = value
        self.cache_key = cache_key
        self._used     = False
        return self

    cdef _mark_use(self, bint expect_used):
        if expect_used is not self._used:
            if expect_used: raise TMsgpackError('ectx was not used.')
            else:           raise TMsgpackError('ectx used twice.')
        self._used = True
        if expect_used: self.value=None; self.cache_key=None

    cpdef put_bytes(self, object _type, object value):
        cdef BaseEncodeBuffer ebuf = self.ebuf
        cdef uint64_t         _len
        self._mark_use(False)
        if type(value) is not bytes: raise TMsgpackError(f'not bytes: {value}')

        bytes_val = <bytes>value
        _len = <uint64_t>len(bytes_val)

        if   _len ==  0:     ebuf.put_uint1(FixBytes0)
        elif _len ==  1:     ebuf.put_uint1(FixBytes1)
        elif _len ==  2:     ebuf.put_uint1(FixBytes2)
        elif _len ==  4:     ebuf.put_uint1(FixBytes4)
        elif _len ==  8:     ebuf.put_uint1(FixBytes8)
        elif _len == 16:     ebuf.put_uint1(FixBytes16)
        elif _len == 20:     ebuf.put_uint1(FixBytes20)
        elif _len == 32:     ebuf.put_uint1(FixBytes32)
        elif _len < ui1_max: ebuf.put_uint1(VarBytes1).put_uint1(<uint8_t>_len)
        elif _len < ui2_max: ebuf.put_uint1(VarBytes2).put_uint2(<uint16_t>_len)
        else:                ebuf.put_uint1(VarBytes8).put_uint8(<uint64_t>_len)

        ectx_put_value(self, _type)
        ebuf.put_bytes(bytes_val)

    cpdef put_sequence(self, object _type, object value):
        cdef uint64_t _len = <uint64_t>len(value)
        self._mark_use(False)

        _tuple_header(self.ebuf, _len)
        ectx_put_value(self, _type)

        for v in value: ectx_put_value(self, v)

    cpdef put_dict(self, object _type, object value, bint sort=False):
        cdef object   pairs = value.items()
        cdef uint64_t _len  = <uint64_t>(2 * len(pairs))
        if sort: pairs = sorted(pairs)

        self._mark_use(False)
        _tuple_header(self.ebuf, _len)
        ectx_put_value(self, _type)

        for k, v in pairs:
            ectx_put_value(self, k)
            ectx_put_value(self, v)

    cpdef set_encode_handler(self, handler):
        if self.cache_key is None: raise TMsgpackError('Repeated set_encode_handler')
        self._decompose_value_cache[self.cache_key] = handler
        self.cache_key = None
        handler.decompose_value(self)

    cpdef set_dict_encode_handler(self, _type, keys):
        self.set_encode_handler(DictEncodeHandler(_type, keys))

cdef class DictEncodeHandler:
    cdef object _type
    cdef object keys

    def __cinit__(self, _type, keys):
        self._type = _type
        self.keys  = keys

    cpdef decompose_value(self, EncodeCtx ectx):
        ectx._mark_use(False)
        _tuple_header(ectx.ebuf, 2 * len(self.keys))
        ectx_put_value(ectx, self._type)

        value = ectx.value
        for key in self.keys:
            ectx_put_value(ectx, key)
            ectx_put_value(ectx, getattr(value, key))

cdef bint _tuple_header(BaseEncodeBuffer ebuf, uint64_t _len):
    if   _len < 17:      ebuf.put_uint1(<uint8_t>(FixTuple0 + _len))
    elif _len < ui1_max: ebuf.put_uint1(VarTuple1).put_uint1(<uint8_t>_len)
    elif _len < ui2_max: ebuf.put_uint1(VarTuple2).put_uint2(<uint16_t>_len)
    else:                ebuf.put_uint1(VarTuple8).put_uint8(<uint64_t>_len)

cpdef BaseEncodeBuffer ebuf_put_value(
    TMsgpackCodec codec, BaseEncodeBuffer ebuf, object value
):
    """Encode value to a msg and put it into ebuf."""
    return ectx_put_value(EncodeCtx(codec, ebuf), value)

cdef ectx_put_value(EncodeCtx ectx, object value):
    cdef TMsgpackCodec    codec = ectx.codec
    cdef BaseEncodeBuffer ebuf  = ectx.ebuf
    cdef int64_t int_val
    cdef bytes str_bytes
    cdef uint64_t _len
    cdef bint bool_val

    cdef object t = type(value)
    cdef object handler

    if t is int:
        # Cast to C int64_t for efficient comparisons and arithmetic
        int_val = PyLong_AsLongLong(value)

        if min_ConstNegInt <= int_val < 0:
            return ebuf.put_uint1(<uint8_t>(int_val + ui1_max))
        if 0 <= int_val < FixInt2:
            return ebuf.put_uint1(<uint8_t>int_val)

        if -i2_max <= int_val < i2_max:
            return ebuf.put_uint1(FixInt2).put_int2(<int16_t>int_val)
        if -i4_max <= int_val < i4_max:
            return ebuf.put_uint1(FixInt4).put_int4(<int32_t>int_val)
        else:
            return ebuf.put_uint1(FixInt8).put_int8(<int64_t>int_val)

    if t is float:
        return ebuf.put_uint1(FixFloat8).put_float8(<float64_t>value)

    if t is str:
        str_bytes = (<str>value).encode('utf8')
        _len = <uint64_t>len(str_bytes)

        # Str length header -- followed by string characters.
        if   _len < 16:      ebuf.put_uint1(<uint8_t>(FixStr0 + _len))
        elif _len < ui1_max: ebuf.put_uint1(VarStr1).put_uint1(<uint8_t>_len)
        elif _len < ui2_max: ebuf.put_uint1(VarStr2).put_uint2(<uint16_t>_len)
        else:                ebuf.put_uint1(VarStr8).put_uint8(<uint64_t>_len)

        return ebuf.put_bytes(str_bytes)

    if t is bool:
        bool_val = <bint>value
        if bool_val is True:  return ebuf.put_uint1(ConstValTrue)
        if bool_val is False: return ebuf.put_uint1(ConstValFalse)
        raise TMsgpackError(f'Illegal boolean value: {value}')

    if t is NoneType: return ebuf.put_uint1(ConstValNone)

    if   t is bytes: ectx._vk(None, None).put_bytes(True, value)
    elif t is tuple: ectx._vk(None, None).put_sequence(True, value)
    elif t is list:  ectx._vk(None, None).put_sequence(False, value)
    elif t is dict:  ectx._vk(None, None).put_dict(None, value, codec.sort_keys)
    elif ectx.use_cache and (handler := ectx._decompose_value_cache.get(t, None)):
        handler.decompose_value(ectx._vk(value, None)); ectx._mark_use(True)
    else:
        codec.decompose_value(ectx._vk(value, t)); ectx._mark_use(True)


